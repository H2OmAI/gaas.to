<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Onboarding â€” GaaS Documentation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="image/png" href="favicon.png">
</head>
<body>
  <header>
    <a class="logo" href="index.html"><img src="logo.png" alt="GaaS"></a>
    <nav>
      <a href="index.html">Docs</a>
      <a href="https://gaas.is">Home</a>
      <a href="https://github.com/H2OmAI">GitHub</a>
    </nav>
  </header>

  <main>
    <h1 class="fade-in">Onboarding</h1>
    <p class="subtitle fade-in">
      From "I want to govern my AI agents" to governed agents &mdash; in hours, not weeks.
    </p>

    <h2 class="fade-in">How It Works</h2>
    <p>
      You provide context about your organization. GaaS builds a governance membrane around your agents. You validate it through conversation and scenario testing, then deploy in shadow mode before going live.
    </p>
    <p>
      You never configure a rules engine. You never write YAML. You provide context, and the system builds protection.
    </p>

    <h2 class="fade-in">The Onboarding Flow</h2>
    <div class="flow fade-in">
      <div class="flow-step">
        <div class="flow-icon">1</div>
        <div class="flow-content">
          <h3>Context Intake</h3>
          <p>Provide a URL, upload documents, describe your business, list your agents &mdash; or any combination. More context produces a better membrane, but a URL alone is enough to start.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-icon">2</div>
        <div class="flow-content">
          <h3>Membrane Generation</h3>
          <p>GaaS analyzes your context and composes a complete governance configuration: policies, risk thresholds, agent delegation limits, enrichment sources, deliberation panel, and escalation chains.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-icon">3</div>
        <div class="flow-content">
          <h3>Conversational Validation</h3>
          <p>A validation agent walks you through what it built. Ask "what if" questions, probe edge cases, correct anything it got wrong. The membrane updates in real time as you refine it.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-icon">4</div>
        <div class="flow-content">
          <h3>Shadow Mode</h3>
          <p>The full governance pipeline runs on real agent actions, but decisions are not enforced. You see what GaaS <em>would</em> have done &mdash; approve, modify, block, escalate &mdash; without any impact on your operations.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-icon">5</div>
        <div class="flow-content">
          <h3>Go Live</h3>
          <p>When you're confident, flip to live mode. Governance decisions are enforced. You can revert to shadow mode at any time.</p>
        </div>
      </div>
    </div>

    <h2 class="fade-in">Context Intake</h2>
    <p>
      The intake system accepts multiple types of input. Each is analyzed by a specialized processor:
    </p>
    <ul>
      <li><strong>URLs</strong> &mdash; your website and API docs are crawled to infer industry, data types, jurisdictions, and integrations</li>
      <li><strong>Documents</strong> &mdash; compliance handbooks, agent architecture docs, internal policies (PDF, DOCX, MD, and more)</li>
      <li><strong>Description</strong> &mdash; free-text description of your organization and what your agents do</li>
      <li><strong>Agent inventory</strong> &mdash; the agents you want governed, their capabilities, and their integrations</li>
    </ul>
    <p>
      Everything feeds into a Unified Context Model &mdash; a structured representation of your organization that drives membrane generation.
    </p>

    <h2 class="fade-in">The Governance Membrane</h2>
    <p>
      The membrane is your complete governance configuration. It includes:
    </p>
    <ul>
      <li>A policy graph spanning universal safety policies through domain-specific and organization-specific rules</li>
      <li>Per-agent governance profiles with delegation limits and action permissions</li>
      <li>Context enrichment configuration &mdash; which data sources to consult for each agent</li>
      <li>Deliberation panel composition tuned to your domain</li>
      <li>Risk thresholds calibrated to your regulatory environment and risk appetite</li>
      <li>Escalation chains with roles, timeouts, and notification preferences</li>
    </ul>

    <div class="note">
      <strong>Quickstart:</strong> For the fastest path, use the <code>POST /v1/onboarding/quickstart</code> endpoint &mdash; a single call that runs intake, analysis, and membrane generation, then drops you straight into shadow mode with an API key.
    </div>

    <h2 class="fade-in">Shadow Mode</h2>
    <p>
      No governance system should go from zero to enforcement without a trial period. In shadow mode, GaaS evaluates every agent action through the full pipeline but never blocks, modifies, or escalates.
    </p>
    <p>
      You review what would have happened. Mark false positives. The membrane is refined based on your feedback. When you're ready, activate live mode with a single call.
    </p>

    <div class="highlight-box">
      <h3>Critical Shadow Alerts</h3>
      <p>
        If GaaS detects an action in shadow mode that would be a critical block in live &mdash; for example, sensitive data on an unsecured channel &mdash; it breaks silence and alerts you immediately. Safety doesn't wait for the shadow period to end.
      </p>
    </div>

    <h2 class="fade-in">Membrane Lifecycle</h2>
    <p>
      The membrane moves through defined states: <code>DRAFT</code> &rarr; <code>SHADOW</code> &rarr; <code>LIVE</code>. You can revert from live to shadow at any time. All audit records from both modes are preserved.
    </p>

    <h2 class="fade-in">Key Endpoints</h2>
    <div class="endpoint">
      <span class="method method-post">POST</span>
      <span class="path">/v1/onboarding/quickstart</span>
      <p class="desc">Single-call onboarding: intake, analyze, generate membrane, issue API key</p>
    </div>
    <div class="endpoint">
      <span class="method method-post">POST</span>
      <span class="path">/v1/onboarding/intake</span>
      <p class="desc">Submit context for analysis</p>
    </div>
    <div class="endpoint">
      <span class="method method-get">GET</span>
      <span class="path">/v1/membranes/{membrane_id}</span>
      <p class="desc">Retrieve your governance membrane</p>
    </div>
    <div class="endpoint">
      <span class="method method-get">GET</span>
      <span class="path">/v1/membranes/{membrane_id}/readiness</span>
      <p class="desc">Check validation readiness score</p>
    </div>
    <div class="endpoint">
      <span class="method method-post">POST</span>
      <span class="path">/v1/membranes/{membrane_id}/activate</span>
      <p class="desc">Activate live governance</p>
    </div>

    <p style="margin-top: 2rem;">
      Ready to start? See the <a class="link" href="getting-started.html">Getting Started</a> guide for a walkthrough.
    </p>

  </main>

  <footer>
    <a href="https://gaas.is">&copy; H2Om</a>
  </footer>

  <script>
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
  </script>
</body>
</html>
