<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Getting Started â€” GaaS Documentation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="image/png" href="favicon.png">
</head>
<body>
  <header>
    <a class="logo" href="index.html"><img src="logo.png" alt="GaaS"></a>
    <nav>
      <a href="index.html">Docs</a>
      <a href="https://gaas.is">Home</a>
      <a href="https://github.com/H2OmAI">GitHub</a>
    </nav>
  </header>

  <main>
    <h1 class="fade-in">Getting Started</h1>
    <p class="subtitle fade-in">
      Add governance to your AI agents in three steps: onboard, integrate, go live.
    </p>

    <!-- STEP 1 -->
    <div class="step-label fade-in">STEP 1</div>
    <h2 class="fade-in">Onboard Your Organization</h2>
    <p>
      The fastest path is the quickstart endpoint. One call handles intake, analysis, membrane generation, and API key provisioning:
    </p>
    <pre><code>POST /v1/onboarding/quickstart
Content-Type: application/json

{
  "organization": {
    "name": "Acme Health",
    "domain_url": "https://acmehealth.com",
    "description": "Healthcare call center with AI agents for billing and scheduling"
  },
  "agents": [
    {
      "name": "Billing Bot",
      "framework": "langchain",
      "action_types": ["communicate", "access"],
      "domains": ["healthcare"]
    }
  ]
}</code></pre>

    <p>
      GaaS analyzes your context, infers the applicable regulatory frameworks, builds a governance membrane, and returns an API key. Your membrane starts in shadow mode &mdash; full evaluation, zero enforcement.
    </p>

    <div class="note">
      <strong>What is a membrane?</strong> Your governance membrane is the complete set of policies, risk thresholds, delegation limits, and configurations that define how GaaS governs your agents. See <a class="link" href="onboarding.html">Onboarding</a> for the full lifecycle.
    </div>

    <hr class="divider">

    <!-- STEP 2 -->
    <div class="step-label fade-in">STEP 2</div>
    <h2 class="fade-in">Integrate Your Agent</h2>
    <p>
      Before your agent takes an action, have it declare the intent to GaaS and act on the decision.
    </p>

    <h3>Python</h3>
    <pre><code><span class="keyword">from</span> gaas_sdk <span class="keyword">import</span> GaaSClient

client = GaaSClient(api_key=<span class="string">"your_api_key"</span>)

<span class="comment"># Declare what the agent wants to do</span>
decision = client.submit_intent(
    agent_id=<span class="string">"billing_bot"</span>,
    action_type=<span class="string">"communicate"</span>,
    verb=<span class="string">"send_email"</span>,
    target_type=<span class="string">"person"</span>,
    target_id=<span class="string">"patient@example.com"</span>,
    sensitivity=<span class="string">"confidential"</span>,
    summary=<span class="string">"Send billing statement to patient"</span>,
    content={<span class="string">"recipient"</span>: <span class="string">"patient@example.com"</span>, <span class="string">"channel"</span>: <span class="string">"email"</span>},
    impact={<span class="string">"reversible"</span>: True, <span class="string">"audience_size"</span>: 1}
)

<span class="comment"># Act on the governance decision</span>
<span class="keyword">if</span> decision.approved:
    send_email(decision.payload)
<span class="keyword">elif</span> decision.blocked:
    log(decision.verdict_reason)</code></pre>

    <h3>TypeScript</h3>
    <pre><code><span class="keyword">import</span> { GaaSClient } <span class="keyword">from</span> <span class="string">'@gaas/sdk'</span>;

<span class="keyword">const</span> client = <span class="keyword">new</span> <span class="func">GaaSClient</span>({ apiKey: <span class="string">'your_api_key'</span> });

<span class="keyword">const</span> decision = <span class="keyword">await</span> client.<span class="func">submitIntent</span>({
  agentId: <span class="string">'billing_bot'</span>,
  actionType: <span class="string">'communicate'</span>,
  verb: <span class="string">'send_email'</span>,
  target: { type: <span class="string">'person'</span>, id: <span class="string">'patient@example.com'</span>, sensitivity: <span class="string">'confidential'</span> },
  summary: <span class="string">'Send billing statement to patient'</span>,
  content: { recipient: <span class="string">'patient@example.com'</span>, channel: <span class="string">'email'</span> },
  impact: { reversible: <span class="keyword">true</span>, audienceSize: 1 }
});

<span class="keyword">if</span> (decision.approved) {
  <span class="func">sendEmail</span>(decision.payload);
} <span class="keyword">else if</span> (decision.blocked) {
  console.<span class="func">log</span>(decision.verdictReason);
}</code></pre>

    <div class="warning">
      <strong>Important:</strong> Always use the <code>payload</code> from the decision response when executing an approved action, not your original content. GaaS may modify the payload for compliance (e.g., adding required disclosures).
    </div>

    <hr class="divider">

    <!-- STEP 3 -->
    <div class="step-label fade-in">STEP 3</div>
    <h2 class="fade-in">Review Shadow Decisions, Then Go Live</h2>
    <p>
      While your membrane is in shadow mode, GaaS evaluates every intent through the full governance pipeline but doesn't enforce any decisions. Use the <a class="link" href="dashboard.html">conversational dashboard</a> to review:
    </p>
    <ul>
      <li>What GaaS <strong>would have blocked</strong> &mdash; these show where governance adds value</li>
      <li>What GaaS <strong>would have modified</strong> &mdash; these show where governance improves action quality</li>
      <li>What GaaS <strong>would have escalated</strong> &mdash; this previews your human review workload</li>
    </ul>
    <p>
      Mark any false positives. The membrane refines based on your feedback. When you're confident, activate live mode:
    </p>
    <pre><code>POST /v1/membranes/{membrane_id}/activate

{
  "activation": {
    "mode": "live"
  }
}</code></pre>
    <p>
      Live mode can be reverted to shadow at any time with a single call. All audit records are preserved across both modes.
    </p>

    <hr class="divider">

    <h2 class="fade-in">What's Next</h2>
    <ul>
      <li><a class="link" href="intent-api.html">Intent Declaration API</a> &mdash; full endpoint reference</li>
      <li><a class="link" href="onboarding.html">Onboarding</a> &mdash; membrane lifecycle, context intake, and shadow mode details</li>
      <li><a class="link" href="dashboard.html">Conversational Dashboard</a> &mdash; monitor governance, review escalations, and explore decisions through natural language</li>
      <li><a class="link" href="sdks.html">SDKs</a> &mdash; Python, TypeScript, and Java client libraries</li>
      <li><a class="link" href="shadow-mode.html">Shadow Mode</a> &mdash; full pipeline evaluation without enforcement</li>
      <li><a class="link" href="observability.html">Observability &amp; Alerting</a> &mdash; metrics, logging, tracing, and anomaly alerts</li>
    </ul>
    <p>
      Questions? Reach out on <a class="link" href="https://github.com/H2OmAI">GitHub</a>.
    </p>

  </main>

  <footer>
    <a href="https://gaas.is">&copy; H2Om</a>
  </footer>

  <script>
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
  </script>
</body>
</html>
